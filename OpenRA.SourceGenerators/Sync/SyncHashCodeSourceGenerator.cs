#region Copyright & License Information
/*
 * Copyright (c) The OpenRA Developers and Contributors
 * This file is part of OpenRA, which is free software. It is made
 * available to you under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version. For more
 * information, see COPYING.
 */
#endregion

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace OpenRA.SourceGenerators.Sync
{
	// https://andrewlock.net/exploring-dotnet-6-part-9-source-generator-updates-incremental-generators/
	[Generator]
	public class SyncHashCodeSourceGenerator : IIncrementalGenerator
	{
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			var classDeclarationsProvider = context.SyntaxProvider
				.CreateSyntaxProvider(
					predicate: static (syntaxNode, _) => syntaxNode.IsPartialClass(),
					transform: static (generatorContext, _) => GetClassDeclarationSymbol(generatorContext))
				.Where(x => x != null)
				.Collect();

			var compilationAndClasses = context.CompilationProvider.Combine(classDeclarationsProvider);

			context.RegisterSourceOutput(compilationAndClasses,
				static (context, source) => ProcessClassDeclarations(source.Left, source.Right, context));
		}

		static ClassDeclarationSyntax GetClassDeclarationSymbol(GeneratorSyntaxContext context)
		{
			if (context.SemanticModel.GetDeclaredSymbol(context.Node) is INamedTypeSymbol typeSymbol
				&& typeSymbol.HasOrInheritsGenerateSyncCodeAttribute()
				&& !typeSymbol.ManuallyImplementsISync())
				return context.Node as ClassDeclarationSyntax;

			return null;
		}

		static void ProcessClassDeclarations(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
		{
			if (classes.IsDefaultOrEmpty)
				return;

			foreach (var classDeclaration in classes.Distinct())
			{
				if (classDeclaration.Parent is not NamespaceDeclarationSyntax namespaceDeclaration)
					continue;

				var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
				var typeSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
				if (typeSymbol == null)
					continue;

				var syncedClassMembers = GetSyncHashElements(typeSymbol);
				var shouldCallBase = typeSymbol.BaseType.HasOrInheritsGenerateSyncCodeAttribute();
				if (!syncedClassMembers.Any() && !shouldCallBase)
					continue;

				var (filename, content) = GenerateClass(namespaceDeclaration.Name, classDeclaration, typeSymbol, syncedClassMembers, shouldCallBase);
				if (content != null)
					context.AddSource(filename, content);
			}
		}

		static IEnumerable<string> GetSyncHashElements(INamedTypeSymbol classSymbol)
		{
			// If not abstract, only care about your own members (and potentially call the base method later if needed).
			if (!classSymbol.IsAbstract)
				return classSymbol.GetMembers().Where(x => x.HasSyncMemberAttribute()).Select(x => x.Name);

			var symbol = classSymbol;
			var syncElements = new List<string>();

			while (symbol.IsAbstract && symbol.Name != "Object")
			{
				var members = symbol.GetMembers().Where(x => x.HasSyncMemberAttribute());
				syncElements.AddRange(members.Select(x => x.Name));
				symbol = symbol.BaseType;
			}

			return syncElements;
		}

		static (string FileName, string Content) GenerateClass(NameSyntax namespaceName,
			ClassDeclarationSyntax classDeclaration, INamedTypeSymbol classSymbol, IEnumerable<string> syncMembers, bool shouldCallBase)
		{
			var className = classSymbol.Name;
			var isSealed = classSymbol.IsSealed;
			var elements = syncMembers.Select(x => $"Sync.Hash({x})");
			if (shouldCallBase)
				elements = Enumerable.Append(elements, "base.GetSyncHash()");

			return ($"{namespaceName}.{className}.g.cs",
				$@"// <auto-generated/>
namespace {namespaceName}
{{
	{classDeclaration.Modifiers} class {className} : {SyncHelpers.SyncInterfaceName}
	{{
#pragma warning disable CS1591 // Apparently disabling in .editorconfig doesn't work for generated code.
		public {(shouldCallBase ? "override" : (isSealed ? "" : "virtual"))} int GetSyncHash()
		{{
			return {string.Join(" ^ ", elements)};
		}}
#pragma warning restore CS1591
	}}
}}");
		}
	}
}
